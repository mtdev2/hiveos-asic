#!/hive/sbin/bash


#
# Copyright (C) 2017  Hiveon Holding LTD
# Distributed under Business Source License 1.1
# License information can be found in the LICENSE.txt file or at https://github.com/minershive/hiveos-asic/blob/master/LICENSE.txt
#


readonly script_mission='Client for ASICs: The Agent'
readonly script_version='0.8.9'
readonly script_basename="${0##*/}"
#
readonly script_DEBUG="${script_DEBUG:-0}" # use value from env if exists


# !!! bash strict mode, no unbound variables
#set -o nounset # commented out for production bc still not tested thoroughly


# functions

function debug_print_variable {
	#
	# Usage: debug_print_variable 'variable_name'...
	#

	# consts
	local -r debug_prefix='|'

	# vars
	local this_var this_var_name this_var_status JSON_array_size variable_color
	local -i max_length=0 this_var_size total_vars_count total_vars_size

	# code
	for this_var in "$@"; do
		(( ${#this_var} > max_length )) && max_length="${#this_var}"
	done

	printf "${DGRAY}%s %-${max_length}.${max_length}s %8.8s %4.4s  %s %s${NOCOLOR}\n" "$debug_prefix" 'var' 'bytes' 'idx' 'value'

	for this_var_name in $( printf '%s\n' "$@" | sort ); do
		JSON_array_size=''
		variable_color="${NOCOLOR}"
		this_var_size=0
		local -n this_var_value="$this_var_name"

		if [[ ! "${this_var_value+is_set}" ]]; then
			this_var_status='unset'
		elif [[ -z "${this_var_value}" ]]; then
			this_var_status='empty'
		else
			this_var_size="${#this_var_value}"
			this_var_status="${this_var_size}"
			if JSON_array_size="$( jq --raw-output 'if type=="array" then . | length else "" end' <<< "$this_var_value" 2> /dev/null )"; then
				variable_color="${GREEN}"
			fi
		fi

		printf "${DGRAY}%s ${variable_color}%-${max_length}.${max_length}s ${CYAN}%8.8s %4.4s  ${DGRAY}'${NOCOLOR}%s${DGRAY}' ${DGRAY}%s${NOCOLOR}\n" "$debug_prefix" "$this_var_name" "$this_var_status" "$JSON_array_size" "$this_var_value"

		(( total_vars_size += this_var_size,
		total_vars_count++ ))
	done

	if (( total_vars_count > 1 )); then
		printf "${DGRAY}%s %u var(s), %u bytes${NOCOLOR}\n" "$debug_prefix" $(( total_vars_count )) $(( total_vars_size ))
	fi
} 1>&2

function jq_batch_process {
	#
	# Usage: jq_batch_process 'jq_batch_request_hashtable_by_ref' 'JSON_input_by_ref'
	#

	# args
	local -r jq_batch_request_hashtable_by_ref="${1-}"
	local -r JSON_input_by_ref="${2-}"

	# vars by ref
	local -r -n _jq_batch_request_hashtable="$jq_batch_request_hashtable_by_ref"
	local -r -n JSON_input="$JSON_input_by_ref"

	# vars
	local -A jq_batch_response_hashtable=()
	local -a jq_batch_response_raw_array=()
	local this_var this_value this_key
	#
	local jq_batch_script='">>BEGIN JQ RESPONSE", ( ' # .[1] |
	local -i this_index=1

	# code
	#
	# 1. assemble the big fat jq batch script with markup
	# 2. reset output vars to null
	#
	for this_var in "${!_jq_batch_request_hashtable[@]}"; do
		# reset output vars to null
		local -n this_var_ref="$this_var"
		this_var_ref='null'

		jq_batch_script+="( \">>BEGIN KEY ${this_var}\", try ( ${_jq_batch_request_hashtable[$this_var]} ) catch null, \"<<END KEY ${this_var}\" )"
		if (( this_index++ < ${#_jq_batch_request_hashtable[@]} )); then
			jq_batch_script+=','
		else
			jq_batch_script+=' ), "<<END JQ RESPONSE"'
		fi
		#jq_batch_script+=$'\n' # pretty-print for debug
	done
	#echo "$jq_batch_script"

	#
	# 3. process jq batch script then get the output to array
	#
	if is_JSON_string_not_empty_or_null "$JSON_input"; then
		#echo "'$JSON_input'" && snore 1
		mapfile -t jq_batch_response_raw_array < <( jq --compact-output --argjson 'max_fan_rpm' "$ASIC_MAX_FAN_RPM" "$jq_batch_script" <<< "$JSON_input" )
		#                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duct tape, might refactor to get rid of it?

		#printf "%s\n" "${jq_batch_response_raw_array[@]}"

		for this_index in "${!jq_batch_response_raw_array[@]}"; do
			this_value="${jq_batch_response_raw_array[this_index]}"
			case "$this_value" in
				'">>BEGIN JQ RESPONSE"')
					# first element
					continue
				;;
				'">>BEGIN KEY '*'"')
					this_key="${this_value//\"}" # remove quotes
					this_key="${this_key##* }" # get last token from string
					#echo "{ # BEGIN $this_key"
					jq_batch_response_hashtable["$this_key"]='null' # let us make it as ='null' by default and then get rid of a argjson_sanitizing
					continue
				;;
				'"<<END KEY '*'"')
					#echo "} # END $this_key"
					this_key='__undefined_key'
					continue
				;;
				'"<<END JQ RESPONSE"')
					break
				;;
				*)
					#echo "	$this_key=$this_value"
					if [[ -n "$this_key" && "$this_key" != '__undefined_key' ]]; then
						jq_batch_response_hashtable["$this_key"]="$this_value"
					else
						errcho "this_key $this_key, this_value $this_value"
					fi
				;;
			esac
		done

		#
		# 4. assign each element of array to the corresponding output var
		#
		for this_var in "${!_jq_batch_request_hashtable[@]}"; do
			this_value="${jq_batch_response_hashtable[$this_var]}"
			if [[ -z "$this_value" ]]; then
				this_value='null'
				errcho "this_var $this_var=$this_value"
			fi
			local -n this_var_ref="$this_var"
			# shellcheck disable=SC2034
			# bc it's a ref var
			this_var_ref="$this_value"
			#echo "$this_var=$this_var_ref"
		done
	else
		errcho "$JSON_input_by_ref variable is empty"
	fi
}

function screen_session_terminate {
	#
	# Usage: screen_session_terminate 'screen_session_name'
	#

	# args
	local -r screen_session_name="${1-}"

	# code
	# shellcheck disable=SC2154
	# bc exitcode_ERROR_SOMETHING_WEIRD declared in library
	[[ -z "$screen_session_name" ]] && return $(( exitcode_ERROR_SOMETHING_WEIRD )) ### TODO rework
	screen -S "$screen_session_name" -X quit > /dev/null
}

function milliseconds_to_seconds {
	#
	# Usage: milliseconds_to_seconds 'milliseconds'
	#

	# args
	local -r -i milliseconds="${1-}"

	# vars
	local -i s_part ms_part
	local ms_part_left_padded sign

	# code
	if (( milliseconds > 0 )); then
		sign=''
	else
		milliseconds=0-milliseconds
		sign='-'
	fi

	(( s_part = milliseconds / 1000,
	ms_part = milliseconds % 1000 / 10 ))
	printf -v ms_part_left_padded '%02u' "$ms_part" # let's leave only 2 digits after the dot bc we don't have a milli precision actually

	if (( ms_part == 0 )); then
		# 1.00 -> 1
		printf '%s%u\n' "$sign" "$s_part"
	elif (( ms_part % 10 == 0 )); then
		# 1.10 -> 1.1
		printf '%s%u.%s\n' "$sign" "$s_part" "${ms_part_left_padded::1}"
	else
		# 1.11 -> 1.11
		printf '%s%u.%s\n' "$sign" "$s_part" "$ms_part_left_padded"
	fi
}

function get_time_difference_in_s {
	#
	# Usage: get_time_difference_in_s 'start_time_in_ms'
	#

	# args
	local -r -i start_time_in_ms="${1-}"

	# vars
	local -i finish_time_in_ms wasted_time_in_ms
	local time_difference_in_s

	# code
	finish_time_in_ms="$( get_system_uptime_in_milliseconds )"
	(( wasted_time_in_ms = finish_time_in_ms - start_time_in_ms ))
	time_difference_in_s="$( milliseconds_to_seconds $(( wasted_time_in_ms )) )"

	echo "$time_difference_in_s"
}

function reduce_hashrate_to_khs {
	#
	# Usage: reduce_hashrate_to_khs 'input_hashrate_value' 'hs|khs|mhs|ghs|ths|phs' 'output_hashrate_in_khs_by_ref'
	#

	# args
	local -r input_hashrate_value="${1-0}"
	local -r input_hashrate_unit="${2-khs}" # khs is the Hive default
	local -r -n output_hashrate_in_khs_by_ref="${3-}"

	# consts
	local -r -A relationship_to_khs_DICT=(
		['phs']='1000000000000'
		['ths']='1000000000'
		['ghs']='1000000'
		['mhs']='1000'
		['khs']='1'
		['hs']='0.001'
	)

	# vars
	local input_hashrate_unit_SAFE relationship_to_khs

	# code

	# first sanitize input_hashrate_unit
	input_hashrate_unit_SAFE="${input_hashrate_unit,,}" # tolower()
	input_hashrate_unit_SAFE="${input_hashrate_unit_SAFE//\/}" # strip an eventual '/'

	if [[ "$input_hashrate_value" == '0' || "$input_hashrate_value" == 'null' || "$input_hashrate_unit_SAFE" == 'khs' ]]; then
		# don't have to calculate anything, just pass input to output
		output_hashrate_in_khs_by_ref="$input_hashrate_value"
		# shellcheck disable=SC2154
		# bc exitcode_OK declared in library
		return $(( exitcode_OK ))
	fi

	relationship_to_khs="${relationship_to_khs_DICT[$input_hashrate_unit_SAFE]-}"
	if [[ -z "$relationship_to_khs" ]]; then
			errcho "Hashrate unit not in dictionary: '$input_hashrate_unit'"
			# shellcheck disable=SC2154
			# bc exitcode_ERROR_NOT_FOUND declared in library
			return $(( exitcode_ERROR_NOT_FOUND ))
	fi

	if [[ "${input_hashrate_value}${relationship_to_khs}" == *[0-9].[0-9]* ]]; then
		# it's FP and we need awk then
		# shellcheck disable=SC2034
		output_hashrate_in_khs_by_ref="$(
			awk -v input_hashrate_value="$input_hashrate_value" \
				-v relationship_to_khs="$relationship_to_khs" \
				'BEGIN{ print input_hashrate_value * relationship_to_khs }'
		)"
	else
		# all integer
		(( output_hashrate_in_khs_by_ref = input_hashrate_value * relationship_to_khs ))
	fi
}

function send_request_to_miner_api {
	#
	# Usage: send_request_to_miner_api 'request_body'
	#

	# args
	local -r request_body="${1-}"

	# consts
	local -r -i timeout=7

	# code
	case "$ASIC_MODEL" in
		'Zig Z1+'|'Zig Z1')
			timeout "$timeout" nc "$miner_API_host" "$miner_API_port" <<< "$request_body" 2> /dev/null
		;;

		*)
			timeout -t "$timeout" nc "$miner_API_host" "$miner_API_port" <<< "$request_body" 2> /dev/null
		;;
	esac | tr -d '\0\n' # sanitize

	return "${PIPESTATUS[0]}"
}

function get_stats_raw {
	#
	# Usage: get_stats_raw
	#

	send_request_to_miner_api '{"command":"stats"}'
}

function get_pools_raw {
	#
	# Usage: get_pools_raw
	#

	send_request_to_miner_api '{"command":"pools"}'
}

function process_pools {
	#
	# !!! may change var from global scope: system_status
	# !!! may change vars from outer scope: POOLS active_pool_id
	#

	# consts
	local -r active_pool_id_RE='^[0-9]+$'

	# vars
	local pools_raw

	# code
	if pools_raw="$( get_pools_raw )"; then
		if POOLS="$( jq --compact-output '.POOLS' <<< "$pools_raw" )"; then
			if active_pool_id="$( jq --raw-output '[. as $object | keys[] | select($object[.]."Stratum Active" == true and $object[.]."Priority" <= 3) as $pool | select($object[$pool]."Getworks")] | .[0]' <<< "$POOLS" 2> /dev/null )"; then
				if [[ "$active_pool_id" =~ $active_pool_id_RE ]]; then
					: ok good to go
				else
					log_line error 'All user pools are not alive:'
					jq --color-output --compact-output \
						'.[] |
							select( .Priority <= 3 ) |
								with_entries(
									select(
										.key |
											test( "Stratum Active", "URL", "User", "Status", "Priority" )
									)
								)' \
						<<< "$POOLS"
					echo
					case "$system_status" in
						'mining' | 'tuning' | 'NA' )
							system_status='deadpool'
						;;
					esac
					return $(( exitcode_ERROR_NOT_FOUND ))
				fi
			else
				log_line warning 'No active pools yet'
				return $(( exitcode_ERROR_NOT_FOUND ))
			fi
		else
			log_line warning 'No pools yet'
		fi
	else
		log_line warning "Failed to read pool stats from $miner_API_host:$miner_API_port"
	fi
}

function cache_cmd {
	#
	# Usage: cache_cmd cmd args...
	#

	# args
	# $@ used down south

	# debug
	if (( script_DEBUG )); then
		local -r -i function_DEBUG=1
	else
		local -r -i function_DEBUG=0 # set to '1' if you'd fancy to debug this function only
	fi
	(( function_DEBUG )) && local -i time_start_caching_in_ms="$( get_system_uptime_in_milliseconds )" # start the timing with millisecond resolution

	# consts
	local -r -i cache_ttl_in_s=50
	local -r cache_FILE='/run/hive/cmd_cache' # '/dev/shm/cmd_cache'
	local hash; printf -v hash "%s<FD>" "${@:1:2}" # construct a hash from the first two elements in "$@", literalize fields delimiters
	local -r       last_time_KEY="$hash:last_time"
	local -r cached_response_KEY="$hash:cached_response"
	local -r cached_exitcode_KEY="$hash:cached_exitcode"
	local -r   avg_cold_time_KEY="$hash:avg_cold_time"
	local -r  avg_hot_time_KEY="$hash:avg_hot_time"

	# hashes
	local -A cmd_cache_array; [[ -s "$cache_FILE" ]] && source "$cache_FILE"
	# direct refs to array elements
	local -n       last_time="cmd_cache_array['$last_time_KEY']"
	local -n cached_response="cmd_cache_array['$cached_response_KEY']"
	local -n cached_exitcode="cmd_cache_array['$cached_exitcode_KEY']"
	local -n   avg_cold_time="cmd_cache_array['$avg_cold_time_KEY']"
	local -n    avg_hot_time="cmd_cache_array['$avg_hot_time_KEY']"

	# flags
	local -i is_cold_FLAG=0

	# vars
	local -i current_time time_wasted_caching_in_ms cache_efficiency=0
	local debug_message tip=''

	# code
	current_time="$( get_current_system_time_in_seconds )"

	[[ -z "$last_time" ]] && last_time=0

	# shellcheck disable=SC2004
	# bc $/${} is necessary while the variable been referenced to an array's single element

	#     vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv -- 1. a usual case when the cache is stale
	if (( ( ( $last_time + cache_ttl_in_s ) < current_time ) || ( $last_time > current_time ) )); then
		#                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -- 2. an edge case when the last time is from the future, magically
		#   ^ fix an unknown bash issue: variable with a reference to a single array element inside an ((arithmetic context))

		# refresh the cache
		cached_response="$( "$@" )"
		cached_exitcode=$?
		last_time="$current_time"
		is_cold_FLAG=1
	fi

	if (( function_DEBUG )); then
		# do timing, averaging, profiling and stuff
		time_wasted_caching_in_ms="$(( $( get_system_uptime_in_milliseconds ) - time_start_caching_in_ms ))"

		if (( is_cold_FLAG )); then
			# shellcheck disable=SC2004
			# bc $/${} is necessary while the variable been referenced to an array's single element
			debug_message="exec '${*:1:2}' (exitcode $cached_exitcode), cache age $(( current_time - $last_time ))s"
			if [[ -z "$avg_cold_time" || "$avg_cold_time" -eq 0 ]]; then
				avg_cold_time="$time_wasted_caching_in_ms"
			else
				# shellcheck disable=SC2004
				# bc $/${} is necessary while the variable been referenced to an array's single element
				avg_cold_time=$(( ( $avg_cold_time + time_wasted_caching_in_ms ) / 2 ))
			fi
		else
			# shellcheck disable=SC2004
			# bc $/${} is necessary while the variable been referenced to an array's single element
			debug_message="cache '${*:1:2}' (exitcode $cached_exitcode), cache age $(( current_time - $last_time ))s"
			if [[ -z "$avg_hot_time" || "$avg_hot_time" -eq 0 ]]; then
				avg_hot_time="$time_wasted_caching_in_ms"
			else
				# shellcheck disable=SC2004
				# bc $/${} is necessary while the variable been referenced to an array's single element
				avg_hot_time=$(( ( $avg_hot_time + time_wasted_caching_in_ms ) / 2 ))
			fi
		fi

		# shellcheck disable=SC2004
		# bc $/${} is necessary while the variable been referenced to an array's single element
		(( $avg_hot_time && $avg_cold_time )) && (( cache_efficiency = ( $avg_cold_time - $avg_hot_time ) * 100 / $avg_hot_time ))
		(( cache_efficiency <= 100 )) && tip='(caching is not recommended)'

		log_line debug "$debug_message, avg hot/cold time ${avg_hot_time:--}ms/${avg_cold_time:--}ms, efficiency ${cache_efficiency}% $tip" 1>&2
	fi

	# shellcheck disable=SC2034
	# bc cmd_cache_array is used in a weird way lol
	(( is_cold_FLAG )) && declare -p cmd_cache_array > "$cache_FILE" # refresh the cache only if cold

	[[ -n "$cached_response" ]] && echo "$cached_response"
	return "$cached_exitcode"
}

function fetch_miner_stats {
	#
	# Usage: fetch_miner_stats 'miner_name'
	#

	# args
	local miner_name="$1"

	# vars
	local stats_raw STATS
	local uptime hashrate_raw
	local POOLS active_pool_id
	local hs temp chip_temp board_temp fan_percent fan_rpm freq freq_new chain_acn chain_acs chain_voltage hw_errors power asicboost ar

	# arrays
	local -a error_vars=() # must be empty

	# traps
	function sanitize_total_khs {
		is_JSON_string_empty_or_null "$total_khs" && total_khs=0
	}
	trap 'sanitize_total_khs' RETURN

	# code
	total_khs=0	# reset the global var
	stats=''	# reset the global var

	case "$ASIC_MODEL" in
		'Antminer '						|\
		'Antminer E3'					|\
		'Antminer S9'|'Antminer S9i'|'Antminer S9j'|'Antminer S9 SE'|'Antminer S9 Hydro'|'Antminer S9 (vnish'*|'Antminer S9'*|'Minecenter S9'|\
		'Antminer S10'*					|\
		'Antminer S11'					|\
		'Antminer S15'					|\
		'Antminer S17'*					|\
		'Antminer T9+'*|'Antminer T9'*	|\
		'Antminer T15'					|\
		'Antminer T17'*					|\
		'Antminer X17'*)
			# echo '{"command":"stats"}' | timeout -t 7 nc localhost 4028 | tr -d '\0\n' | sed 's/}{/},{/' | jq '.'
			stats_raw="$( get_stats_raw )"
			if [[ $? -ne 0 || -z "$stats_raw" ]]; then
				system_status="$( ant-functions.sh 'hiveon_status' 'ERR_NO_STATS' )" # check for 'tuning' state
				log_line warning "Failed to read $miner_name stats from $miner_API_host:$miner_API_port"
			else
				STATS="$( jq --compact-output '.STATS' <<< "${stats_raw//\}\{/\},\{}" )" # fix broken API answer (like S9): '}{' -> '},{'

				hashrate_raw="$( jq --raw-output '.[1]."GHS 5s"' <<< "$STATS" )" #14162.91 gh/s = 14 th/s
				if [[ -z "$ASIC_TOTAL_HASHRATE_UNITS" ]]; then
					reduce_hashrate_to_khs "$hashrate_raw" "$ASIC_CHAIN_HASHRATE_UNITS" 'total_khs'
				else
					reduce_hashrate_to_khs "$hashrate_raw" "$ASIC_TOTAL_HASHRATE_UNITS" 'total_khs'
				fi

				system_status="$( ant-functions.sh 'hiveon_status' "$STATS" )"

				process_pools || return

				uptime="$(			jq --raw-output		'.[1].Elapsed'																																			<<< "$STATS" )"
				hs="$(				jq --compact-output	'.[1] | with_entries( select(.key | test("chain_rate\\d+")) )	| to_entries | [ .[].value | if . != "" then tonumber else "" end  ]'					<<< "$STATS" 2> /dev/null )" || error_vars+=( "hs#$?" )
				temp="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("temp2_\\d+")) )		| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "temp#$?" )
				chip_temp="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("temp_chip\\d+")))		| to_entries | [ .[].value | split("-") | max | if . != "" then tonumber else "" end ]'	<<< "$STATS" 2> /dev/null )" || error_vars+=( "chip_temp#$?" )
				board_temp="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("temp\\d+$")) )		| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "board_temp#$?" )
				fan_percent="$(		jq --compact-output --argjson max_fan_rpm "$ASIC_MAX_FAN_RPM" \
														'.[1] | with_entries( select(.key | test("fan\\d+")) )			| to_entries | [ .[].value / $max_fan_rpm * 100 + 0.5 | floor ]'						<<< "$STATS" 2> /dev/null )" || error_vars+=( "fan_percent#$?" )
				fan_rpm="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("fan\\d+")) )			| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "fan_rpm#$?" )
				freq="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("freq_avg\\d+")) )		| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "freq#$?" )
				freq_new="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("freq\\d+")) )			| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "freq_new#$?" )
				chain_acn="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("chain_acn\\d+")) )	| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "chain_acn#$?" )

				if [[ -s /hive-config/use-smart-acs ]]; then
					# experimental traffic reduction algo
					case "$( < /hive-config/use-smart-acs )" in
						'ok')	log_line warning 'smart-acs traffic reduction: OK mode'
								chain_acs="$(
									jq --compact-output	'.[1] | with_entries( select(.key | test("chain_acs\\d+")) )	| to_entries | [ .[].value | if test("^[ o]+$") then "ok" else . end ] | if (unique_by(.=="") | length) == 1 then [] else . end'	<<< "$STATS" 2> /dev/null )" || error_vars+=( "chain_acs#$?" )
								;;
						'full')	log_line warning 'smart-acs traffic reduction: FULL mode'
								chain_acs="$(
									jq --compact-output	'.[1] | with_entries( select(.key | test("chain_acs\\d+")) )	| to_entries | [ .[].value | if test("^[ o]+$") then "" else . end ] | if (unique_by(.=="") | length) == 1 then [] else . end'		<<< "$STATS" 2> /dev/null )" || error_vars+=( "chain_acs#$?" )
								;;
					esac
				else
					chain_acs="$(	jq --compact-output	'.[1] | with_entries( select(.key | test("chain_acs\\d+")) )	| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "chain_acs#$?" )
				fi

				chain_voltage="$(	jq --compact-output	'.[1] | with_entries( select(.key | test("chain_voltage\\d+")) )| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "chain_voltage#$?" )
				hw_errors="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("chain_hw\\d+")) )		| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "hw_errors#$?" )
#				power="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("chain_power\\d+")) )	| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "power#$?" )
				power="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("chain_power\\d+")) )	| to_entries | from_entries'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "power#$?" )
				asicboost="$(		jq					'.[1] | with_entries( select(.key | test("chain_power$")) )		| to_entries | .[].value | test("AB") | if . == true then 1 else 0 end'					<<< "$STATS" 2> /dev/null )" || error_vars+=( "asicboost#$?" )
				ar="$(				jq --compact-output --argjson pool "$active_pool_id" \
														'.[$pool] | with_entries( select(.key | test("^Accepted","^Rejected","Get Failures")) ) | to_entries | [.[].value]'										<<< "$POOLS" 2> /dev/null )" || error_vars+=( "ar#$?" )

				[[ "$chain_voltage" == '[]'	]] && chain_voltage="$( cache_cmd ant-functions.sh 'hiveon_voltage' <<< "$chain_acn" )"
				[[ "$power" != '{}'			]] && power="$( cache_cmd ant-functions.sh 'hiveon_power' "$power" "$chain_acn" )"
				[[ "$chip_temp" =~ .[0-9]	]] && temp="$chip_temp"
				[[ "$freq_new" =~ .[0-9]	]] && freq="$freq_new"

				stats="$( jq --null-input --compact-output																		\
					--arg		'algo'			"$ASIC_ALGO"					--argjson	'hs'		"${hs:-null}"			\
					--arg		'hs_units'		"$ASIC_CHAIN_HASHRATE_UNITS"	--argjson	'temp'		"${temp:-null}"			\
					--argjson	'board_temp'	"${board_temp:-null}"			--argjson	'fan'		"${fan_percent:-null}"	\
					--argjson	'fan_rpm'		"${fan_rpm:-null}"				--argjson	'freq'		"${freq:-null}"			\
					--argjson	'chain_voltage'	"${chain_voltage:-null}"		--argjson	'acn'		"${chain_acn:-null}"	\
					--argjson	'power'			"${power:-null}"				--argjson	'hw_errors'	"${hw_errors:-null}"	\
					--argjson	'status'		"${chain_acs:-null}"			--argjson	'uptime'	"${uptime:-null}"		\
					--argjson	'ar'			"${ar:-null}"					--argjson	'asicboost'	"${asicboost:-null}"	\
																																\
					'{$algo,$hs,$hs_units,$temp,$board_temp,$fan,$fan_rpm,$freq,$chain_voltage,$acn,$power,$hw_errors,$status,$uptime,$ar,$asicboost}' \
																																\
					2> /dev/null
				)" || error_vars+=( "stats#$?" )
				(( script_DEBUG )) && debug_print_variable stats ASIC_ALGO hs ASIC_CHAIN_HASHRATE_UNITS temp chip_temp board_temp fan_percent fan_rpm freq freq_new chain_voltage chain_acn power hw_errors chain_acs uptime ar asicboost
			fi
		;;

		'Antminer A3'										|\
		'Antminer D3'|'Antminer D3 Blissz'*|'Antminer DR3'	|\
		'Antminer L3+'*										|\
		'Antminer S7'										|\
		'Antminer X3'										|\
		'Antminer Z9'*										|\
		'Antminer Z11'*)
			# echo '{"command":"stats"}' | timeout -t 7 nc localhost 4028 | tr -d '\0\n'
			stats_raw="$( get_stats_raw )"
			if [[ $? -ne 0 || -z "$stats_raw" ]]; then
				system_status="$( ant-functions.sh 'hiveon_status' 'ERR_NO_STATS' )" # check for 'tuning' state
				log_line warning "Failed to read $miner_name stats from $miner_API_host:$miner_API_port"
			else
				STATS="$( jq --compact-output '.STATS' <<< "${stats_raw//\}\{/\},\{}" )" # fix broken API: '}{' -> '},{'

				#if [[ -z $algo || $algo == 'null' ]]; then
				#	algo=`echo '{"command":"coin"}' | nc localhost 4028 | jq '.COIN."Hash Method"'`
				#fi

				hashrate_raw="$( jq --raw-output '.[1]."GHS 5s"' <<< "$STATS" )" #14162.91 gh/s = 14 th/s
				if [[ -z "$ASIC_TOTAL_HASHRATE_UNITS" ]]; then
					reduce_hashrate_to_khs "$hashrate_raw" "$ASIC_CHAIN_HASHRATE_UNITS" 'total_khs'
				else
					reduce_hashrate_to_khs "$hashrate_raw" "$ASIC_TOTAL_HASHRATE_UNITS" 'total_khs'
				fi

				system_status="$( ant-functions.sh 'hiveon_status' "$STATS" )"

				process_pools || return

				uptime="$(			jq --raw-output		'.[1].Elapsed'																																	<<< "$STATS" )"
				hs="$(				jq --compact-output	'.[1] | with_entries( select(.key | test("chain_rate\\d+")) )			| to_entries | [ .[].value | if . != "" then tonumber else "" end  ]'	<<< "$STATS" 2> /dev/null )" || error_vars+=( "hs#$?" )
				temp="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("temp2_\\d+")) )				| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "temp#$?" )
				board_temp="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("temp\\d+$")) )				| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "board_temp#$?" )
				fan_percent="$(		jq --compact-output --argjson max_fan_rpm "$ASIC_MAX_FAN_RPM" \
														'.[1] | with_entries( select(.key | test("fan\\d+")) )					| to_entries | [.[].value / $max_fan_rpm * 100 + 0.5 | floor ]'			<<< "$STATS" 2> /dev/null )" || error_vars+=( "fan_percent#$?" )
				fan_rpm="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("fan\\d+")) )					| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "fan_rpm#$?" )
				freq="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("frequency\\d+")) )			| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "freq#$?" )
				chain_acn="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("chain_acn\\d+")) )			| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "chain_acn#$?" )
				power="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("chain_power\\d+")) )			| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "power#$?" )
				chain_acs="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("chain_acs\\d+")) )			| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "chain_acs#$?" )
				chain_voltage="$(	jq --compact-output	'.[1] | with_entries( select(.key | test("^([a-z]+_)?voltage\\d+$")) )	| to_entries | [ .[].value ]'											<<< "$STATS" 2> /dev/null )" || error_vars+=( "chain_voltage#$?" ) #' highlighting fix
				#                                                                                 ^^^^^^^^^^^^^^^^^^^^^^^ L3+ Hiveon has 'voltageN' keys, not 'chain_voltageN'
				hw_errors="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("chain_hw\\d+")) )				| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "hw_errors#$?" )
				ar="$(				jq --compact-output --argjson pool "$active_pool_id" \
													'.[$pool] | with_entries( select(.key | test("^Accepted","^Rejected","Get Failures")) ) | to_entries | [.[].value]'									<<< "$POOLS" 2> /dev/null )" || error_vars+=( "ar#$?" )

				[[ "$chain_voltage" == '[]' ]] && chain_voltage="$( cache_cmd ant-functions.sh 'hiveon_voltage' <<< "$chain_acn" )"
				miner_count="$( jq '. | length' <<< "$chain_acn" )"
				if [[ "$( jq --raw-output length <<< "$freq" )" -ne "$miner_count" ]]; then
					freq_new='[]'
					freq="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("frequency")) )				| to_entries | [.[].value]'												<<< "$STATS" )" || error_vars+=( "freq#$?" )
					freq_num="$( jq --raw-output '.[0]' <<< "$freq" )" || error_vars+=( "freq_num#$?" )
					for (( c = 1;  c <= miner_count; c++ )); do
						freq_new="$( jq --raw-output --arg freq_num "$freq_num" '[.[], $freq_num | tonumber]' <<< "$freq_new" )" || error_vars+=( "freq_new#$?" )
					done
				else
					freq_new="$freq"
				fi

				stats="$( jq --null-input --compact-output																					\
					--arg		'algo'			"$ASIC_ALGO"					--argjson	'hs'		"${hs:-null}"						\
					--arg		'hs_units'		"$ASIC_CHAIN_HASHRATE_UNITS"	--argjson	'temp'		"${temp:-null}"						\
					--argjson	'board_temp'	"${board_temp:-null}"			--argjson	'fan'		"${fan_percent:-null}"				\
					--argjson	'fan_rpm'		"${fan_rpm:-null}"				--argjson	'freq'		"${freq_new:-null}"					\
					--argjson	'chain_voltage'	"${chain_voltage:-null}"		--argjson	'acn'		"${chain_acn:-null}"				\
					--argjson	'power'			"${power:-null}"				--argjson	'hw_errors'	"${hw_errors:-null}"				\
					--argjson	'status'		"${chain_acs:-null}"			--argjson	'uptime'	"${uptime:-null}"					\
					--argjson	'ar'			"${ar:-null}"																				\
																																			\
					'{$algo,$hs,$hs_units,$temp,$board_temp,$fan,$fan_rpm,$freq,$chain_voltage,$acn,$power,$hw_errors,$status,$uptime,$ar}'	\
																																			\
					2> /dev/null
				)" || error_vars+=( "stats#$?" )
				(( script_DEBUG )) && debug_print_variable stats ASIC_ALGO hs ASIC_CHAIN_HASHRATE_UNITS temp chip_temp board_temp fan_percent fan_rpm freq freq_new chain_voltage chain_acn power hw_errors chain_acs uptime ar asicboost
			fi
		;;

		'Zig Z1+'	|\
		'Zig Z1')
			# echo '{"command":"stats"}' | timeout -t 7 nc localhost 4028 | tr -d '\0\n'
			stats_raw="$( get_stats_raw )"
			if [[ $? -ne 0 || -z "$stats_raw" ]]; then
				log_line warning "Failed to read $miner_name stats from $miner_API_host:$miner_API_port"
			else
				STATS="$( jq --compact-output '.STATS' <<< "$stats_raw" )"

				hashrate_raw="$( jq --raw-output '.[0]."MHS 30S"' <<< "$STATS" )"
				reduce_hashrate_to_khs "$hashrate_raw" "$ASIC_CHAIN_HASHRATE_UNITS" 'total_khs'

				uptime="$(		jq --raw-output		'.[0].Elapsed'																																												<<< "$STATS" )"
				hs="$(			jq --compact-output	'.[0]						| with_entries( select(.key | test("CH\\d+") ) )			| to_entries | [.[].value | ."MHS 30S"]'															<<< "$STATS" )" || error_vars+=( "hs#$?" )
				temp="$(		jq --compact-output	'.[0]						| with_entries( select(.key | test("CH\\d+") ) )			| to_entries | [.[].value | ."Temperature"]'														<<< "$STATS" )" || error_vars+=( "temp#$?" )
				fan_percent="$(	jq --compact-output --argjson max_fan_rpm "$ASIC_MAX_FAN_RPM" \
													'.[0]						| with_entries( select(.key | test("Fan In|Fan Out") ) )	| to_entries | [.[].value / $max_fan_rpm * 100 + 0.5 | floor ]'										<<< "$STATS" )" || error_vars+=( "fan_percent#$?" )
				fan_rpm="$(		jq --compact-output	'.[0]						| with_entries( select(.key | test("Fan In|Fan Out") ) )	| to_entries | [.[].value ]'																		<<< "$STATS" )" || error_vars+=( "fan_rpm#$?" )
				freq="$(		jq --compact-output	'.[0].Frequency as $freq	| .[0] | with_entries( select(.key | test("CH\\d+") ) )		| to_entries | [.[].value | $freq ]'																<<< "$STATS" )" || error_vars+=( "freq#$?" )
				chain_acn="$(	jq --compact-output	'.[0]						| with_entries( select(.key | test("CH\\d+") ) )			| to_entries | [.[].value | .status | length ]'														<<< "$STATS" )" || error_vars+=( "chain_acn#$?" )
				chain_acs="$(	jq --compact-output	'.[0]						| with_entries( select(.key | test("CH\\d+") ) )			| to_entries | [.[].value | .status | [.[].accept | if . > 0 then "o" else "x" end ] | join("") ]'	<<< "$STATS" )" || error_vars+=( "chain_acs#$?" )
#				hw_errors="$(	jq --compact-output	'.[1]						| with_entries( select(.key | test("chain_hw\\d+")) )		| to_entries | [.[].value]'																			<<< "$STATS" )" || error_vars+=( "hw_errors#$?" )

				stats="$( jq --null-input --compact-output																		\
					--arg		'algo'			"$ASIC_ALGO"					--argjson	'hs'		"${hs:-null}"			\
					--arg		'hs_units'		"$ASIC_CHAIN_HASHRATE_UNITS"	--argjson	'temp'		"${temp:-null}"			\
					--argjson	'fan'			"${fan_percent:-null}"			--argjson	'fan_rpm'	"${fan_rpm:-null}"		\
					--argjson	'freq'			"${freq:-null}"					--argjson	'acn'		"${chain_acn:-null}"	\
					--argjson	'status'		"${chain_acs:-null}"			--argjson	'uptime'	"${uptime:-null}"		\
																																\
					'{$algo, $hs, $hs_units, $temp, $fan, $fan_rpm, $freq, $acn, $status, $uptime}'								\
																																\
					2> /dev/null
				)" || error_vars+=( "stats#$?" )
				(( script_DEBUG )) && debug_print_variable stats ASIC_ALGO hs ASIC_CHAIN_HASHRATE_UNITS temp chip_temp board_temp fan_percent fan_rpm freq freq_new chain_voltage chain_acn power hw_errors chain_acs uptime ar asicboost
			fi
		;;

		'b29+.g19'						|\
		'a9+.g19'						|\
		'd9.g19'						|\
		's11.g19'						|\
		't2t.soc'|'t2t+.soc'			|\
		't2th.soc'|'t2th+.soc'|'t2thf.soc'|'t2thf+.soc'|'t2thl+.soc'|'t2thm.soc'|\
		't2ti.soc'						|\
		't2ts.soc'						|\
		't2tz.soc'						|\
		't1.g19'						|\
		't3.soc'|'t3+.soc'|'t3h+.soc')
			# echo '{"command":"stats"}' | timeout -t 7 nc localhost 4028 | tr -d '\0\n'
			stats_raw="$( get_stats_raw )"
			if [[ $? -ne 0 || -z "$stats_raw" ]]; then
				log_line warning "Failed to read $miner_name stats from $miner_API_host:$miner_API_port"
			else
				#stats_raw="$( sed 's/}{/\},{/' <<< "$stats_raw" )"
				STATS="$( jq --compact-output '.STATS' <<< "$stats_raw" )"

				#if [[ -z $algo || $algo == 'null' ]]; then
				#	algo=`echo '{"command":"coin"}' | nc localhost 4028 | jq '.COIN."Hash Method"'`
				#fi

				hashrate_raw="$( jq --raw-output '.[-1] | .[] | add' < /tmp/stats.json )"
				reduce_hashrate_to_khs "$hashrate_raw" "$ASIC_CHAIN_HASHRATE_UNITS" 'total_khs'

				uptime="$(		jq --raw-output		'.[0].Elapsed'																											<<< "$STATS"		)"
				hs="$(			jq --raw-output		'[.[-1] | .[] | .[]]'																									< /tmp/stats.json	)" || error_vars+=( "hs#$?" )
				temp="$(		jq --compact-output	'[.[] | with_entries( select(.key | test("^Temp$")) )			| to_entries | .[].value]'								<<< "$STATS"		)" || error_vars+=( "temp#$?" )
				fan_percent="$(	jq --compact-output	'[.[] | with_entries( select(.key | test("^Fan duty$")) )		| to_entries | .[].value]'								<<< "$STATS"		)" || error_vars+=( "fan_percent#$?" )
				freq="$(		jq --compact-output	'[.[] | with_entries( select(.key | test("^PLL")) )				| to_entries | .[].value]'								<<< "$STATS"		)" || error_vars+=( "freq#$?" )
				chain_acn="$(	jq --compact-output	'[.[] | with_entries( select(.key | test("Num chips")) )		| to_entries | .[].value]'								<<< "$STATS"		)" || error_vars+=( "chain_acn#$?" )
				chain_acs="$(	jq --compact-output	'[.[] | with_entries( select(.key | test("Num active chips")) )	| to_entries | .[].value]'								<<< "$STATS"		)" || error_vars+=( "chain_acs#$?" )
				hw_errors="$(	jq --compact-output	'[.[] | with_entries( select(.key | test("HW errors")) )		| to_entries | [.[].value] | add | select(.!=null)]'	<<< "$STATS"		)" || error_vars+=( "hw_errors#$?" )

				stats="$( jq --null-input --compact-output																		\
					--arg		'algo'			"$ASIC_ALGO"					--argjson	'hs'		"${hs:-null}"			\
					--arg		'hs_units'		"$ASIC_CHAIN_HASHRATE_UNITS"	--argjson	'temp'		"${temp:-null}"			\
					--argjson	'fan'			"${fan_percent:-null}"			--argjson	'freq'		"${freq:-null}"			\
					--argjson	'acn'			"${chain_acn:-null}"			--argjson	'hw_errors'	"${hw_errors:-null}"	\
					--argjson	'status'		"${chain_acs:-null}"			--argjson	'uptime'	"${uptime:-null}"		\
																																\
					'{$algo, $hs, $hs_units, $temp, $fan, $freq, $acn, $hw_errors, $status, $uptime}'							\
																																\
					2> /dev/null
				)" || error_vars+=( "stats#$?" )
				(( script_DEBUG )) && debug_print_variable stats ASIC_ALGO hs ASIC_CHAIN_HASHRATE_UNITS temp chip_temp board_temp fan_percent fan_rpm freq freq_new chain_voltage chain_acn power hw_errors chain_acs uptime ar asicboost
			fi
		;;

		'T4.G19')
			# echo '{"command":"stats"}' | timeout -t 7 nc localhost 4028 | tr -d '\0\n'
			stats_raw="$( send_request_to_miner_api '{"command":"devs"}' )"
			if [[ $? -ne 0 || -z "$stats_raw" ]]; then
				log_line warning "Failed to read $miner_name stats from $miner_API_host:$miner_API_port"
			else
				STATS="$( jq --compact-output '.DEVS' <<< "$stats_raw" )"

				#if [[ -z $algo || $algo == 'null' ]]; then
				#	algo=`echo '{"command":"coin"}' | nc localhost 4028 | jq '.COIN."Hash Method"'`
				#fi

				hashrate_raw="$( jq --raw-output '[.[]["MHS av"]] | add' <<< "$STATS" )"
				reduce_hashrate_to_khs "$hashrate_raw" "$ASIC_CHAIN_HASHRATE_UNITS" 'total_khs'

				uptime="$(		jq --raw-output		'.[0]["Device Elapsed"]'																	<<< "$STATS" )"
				hs="$(			jq --compact-output	'[.[] | with_entries( select(.key | test("MHS 5s")) )			| to_entries | .[].value]'	<<< "$STATS" )" || error_vars+=( "hs#$?" )
				temp="$(		jq --compact-output	'[.[] | with_entries( select(.key | test("TempAVG")) )			| to_entries | .[].value]'	<<< "$STATS" )" || error_vars+=( "temp#$?" )
				freq="$(		jq --compact-output	'[.[] | with_entries( select(.key | test("CORE")) )				| to_entries | .[].value]'	<<< "$STATS" )" || error_vars+=( "freq#$?" )
				chain_acn="$(	jq --compact-output	'[.[] | with_entries( select(.key | test("DUTY")) )				| to_entries | .[].value]'	<<< "$STATS" )" || error_vars+=( "chain_acn#$?" )
#				chain_acs="$(	jq --compact-output	'[.[] | with_entries( select(.key | test("Num active chips")) )	| to_entries | .[].value]'	<<< "$STATS" )" || error_vars+=( "chain_acs#$?" )
				hw_errors="$(	jq --compact-output	'[.[] | with_entries( select(.key | test("Hardware Errors")) )	| to_entries | .[].value]'	<<< "$STATS" )" || error_vars+=( "hw_errors#$?" )

				stats="$( jq --null-input --compact-output																		\
					--arg		'algo'			"$ASIC_ALGO"					--argjson	'hs'		"${hs:-null}"			\
					--arg		'hs_units'		"$ASIC_CHAIN_HASHRATE_UNITS"	--argjson	'temp'		"${temp:-null}"			\
					--argjson	'freq'			"${freq:-null}"					--argjson	'acn'		"${chain_acn:-null}"	\
					--argjson	'hw_errors'		"${hw_errors:-null}"			--argjson	'uptime'	"${uptime:-null}"		\
																																\
					'{$algo, $hs, $hs_units, $temp, $freq, $acn, $hw_errors, $uptime}'											\
																																\
					2> /dev/null
				)" || error_vars+=( "stats#$?" )
				(( script_DEBUG )) && debug_print_variable stats ASIC_ALGO hs ASIC_CHAIN_HASHRATE_UNITS temp chip_temp board_temp fan_percent fan_rpm freq freq_new chain_voltage chain_acn power hw_errors chain_acs uptime ar asicboost
			fi
		;;

		'Toddminer C1'*)
			stats="$( todd_api stats )"
			hashrate_raw="$( jq '.hs | add' <<< "$stats" )"
			reduce_hashrate_to_khs "$hashrate_raw" "$ASIC_CHAIN_HASHRATE_UNITS" 'total_khs'
			# shellcheck disable=SC2071
			# bc of float comparison
			[[ "$total_khs" > '0' ]] && system_status='mining'
			(( script_DEBUG )) && debug_print_variable stats
		;;

		'Blackminer F1'*)
			# echo '{"command":"stats"}' | timeout -t 7 nc localhost 4028 | tr -d '\0\n'
			stats_raw="$( get_stats_raw )"
			if [[ $? -ne 0 || -z "$stats_raw" ]]; then
				log_line warning "Failed to read $miner_name stats from $miner_API_host:$miner_API_port"
			else
				STATS="$( jq --compact-output '.STATS' <<< "${stats_raw//\}\{/\},\{}" )" # fix broken API: '}{' -> '},{'

				local COIN="$( jq --raw-output '."coin-type"' < /config/cgminer.conf )"
				POWER=(50)
				[[ -e /hive/share/blackminer/blackminer.json ]] && BBDATA="$( jq --exit-status '.' < /hive/share/blackminer/blackminer.json )"
				if (( $? == 0 )); then
					ASIC_ALGO="$( jq --raw-output --arg coin "$COIN" '.[$coin].algo' <<< "$BBDATA" )" || error_vars+=( "ASIC_ALGO#$?" )
					POWER="$( jq --raw-output --arg coin "$COIN" '.[$coin].power' <<< "$BBDATA" )" || error_vars+=( "POWER#$?" )
				fi

				##echo $ASIC_ALGO $POWER
				#if [[ -z $algo || $algo == 'null' ]]; then
				#	algo=`echo '{"command":"coin"}' | nc localhost 4028 | jq '.COIN."Hash Method"'`
				#fi

				hashrate_raw="$( jq --raw-output '.[1]."GHS 5s"' <<< "$STATS" )" #14162.91 gh/s = 14 th/s
				reduce_hashrate_to_khs "$hashrate_raw" "$ASIC_CHAIN_HASHRATE_UNITS" 'total_khs'

				process_pools || return

				uptime="$(		jq --raw-output		'.[1].Elapsed'																													<<< "$STATS" )"
				hs="$(			jq --compact-output	'.[1]	| with_entries( select(.key | test("chain_rate\\d+")) )	| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "hs#$?" )
#				temp="$(		jq --compact-output	'.[1]	| with_entries( select(.key | test("temp2_\\d+")) )		| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "temp#$?" )
				temp="$(		jq --compact-output	'.[1]	| with_entries( select(.key | test("temp\\d+$")) )		| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "temp#$?" )
				board_temp="$(	jq --compact-output	'.[1]	| with_entries( select(.key | test("temp\\d+$")) )		| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "board_temp#$?" )
				fan_percent="$(	jq --compact-output --argjson max_fan_rpm "$ASIC_MAX_FAN_RPM" \
													'.[1]	| with_entries( select(.key | test("fan\\d+")) )		| to_entries | [.[].value / $max_fan_rpm * 100 + 0.5 | floor ]'	<<< "$STATS" )" || error_vars+=( "fan_percent#$?" )
				fan_rpm="$(		jq --compact-output	'.[1]	| with_entries( select(.key | test("fan\\d+")) )		| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "fan_rpm#$?" )
				freq="$(		jq --compact-output	'.[1]	| with_entries( select(.key | test("frequency\\d+")) )	| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "freq#$?" )
				miner_count="$(	jq --compact-output	'.[1]	| with_entries( select(.key | test("miner_count")) )	| to_entries | .[].value'										<<< "$STATS" )" || error_vars+=( "miner_count#$?" )
				chain_acn="$(	jq --compact-output	'.[1]	| with_entries( select(.key | test("chain_acn\\d+")) )	| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "chain_acn#$?" )
				chain_acs="$(	jq --compact-output	'.[1]	| with_entries( select(.key | test("chain_acs\\d+")) )	| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "chain_acs#$?" )
				hw_errors="$(	jq --compact-output	'.[1]	| with_entries( select(.key | test("chain_hw\\d+")) )	| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "hw_errors#$?" )
				ar="$(			jq --compact-output --argjson pool "$active_pool_id" \
									'.[$pool] | with_entries( select(.key | test("^Accepted","^Rejected","Get Failures")) ) | to_entries | [.[].value]'	<<< "$POOLS" )" || error_vars+=( "ar#$?" )

				if [[ "$( jq --raw-output length <<< "$freq" )" -ne "$miner_count" ]]; then
					freq_new='[]'
					freq="$(	jq --compact-output	'.[1]	| with_entries( select(.key | test("frequency")) )		| to_entries | [.[].value]'										<<< "$STATS" )"
					freq_num="$( jq --raw-output '.[0]' <<< "$freq" )"
					for (( c=1; c<=miner_count; c++ )); do
						freq_new="$( jq --raw-output --arg freq_num "$freq_num" '[.[], $freq_num | tonumber]' <<< "$freq_new" )"
					done
				else
					freq_new="$freq"
				fi

				power="$( jq --slurp --compact-output '.' <<< "$POWER" )"

				stats="$( jq --null-input --compact-output																		\
					--arg		'algo'			"$ASIC_ALGO"					--argjson	'hs'		"${hs:-null}"			\
					--arg		'hs_units'		"$ASIC_CHAIN_HASHRATE_UNITS"	--argjson	'temp'		"${temp:-null}"			\
					--argjson	'board_temp'	"${board_temp:-null}"			--argjson	'fan'		"${fan_percent:-null}"	\
					--argjson	'fan_rpm'		"${fan_rpm:-null}"				--argjson	'freq'		"${freq_new:-null}"		\
					--argjson	'acn'			"${chain_acn:-null}"			--argjson	'power'		"${power:-null}"		\
					--argjson	'ar'			"${ar:-null}"					--argjson	'hw_errors'	"${hw_errors:-null}"	\
					--argjson	'status'		"${chain_acs:-null}"			--argjson	'uptime'	"${uptime:-null}"		\
																																\
					'{$algo,$hs,$hs_units,$temp,$board_temp,$fan,$fan_rpm,$freq,$acn,$power,$ar,$hw_errors,$status,$uptime}'	\
																																\
					2> /dev/null
				)" || error_vars+=( "stats#$?" )
				(( script_DEBUG )) && debug_print_variable stats ASIC_ALGO hs ASIC_CHAIN_HASHRATE_UNITS temp chip_temp board_temp fan_percent fan_rpm freq freq_new chain_voltage chain_acn power hw_errors chain_acs uptime ar asicboost
			fi
		;;

		*)
			errcho "Unsupported ASIC model '$ASIC_MODEL'"
			MINER='unknown'
		;;
	esac

	# show vars with errors, if any
	(( ${#error_vars[@]} )) && log_line debug "Missing keys: ${error_vars[*]}"
}

function get_loadavg_as_json_array {
	# vars
	local LA_1m LA_5m LA_15m

	# code
	# /proc/loadavg: '1.24 1.25 1.34 3/251 5135'
	read -r LA_1m LA_5m LA_15m _ < /proc/loadavg
	printf '[%0.1f,%0.1f,%0.1f]\n' "$LA_1m" "$LA_5m" "$LA_15m"
}

function get_diskfree_as_string {
	# arrays
	local -a lines_array last_line_array

	# vars
	local diskfree

	# code
	#df -h "/${ASIC_MOUNT_PATH}" | awk '{ print $4 }' | tail -n 1 | sed 's/%//'
	readarray -s 1 -t lines_array < <( df -h "/${ASIC_MOUNT_PATH}" )
	last_line_array=( ${lines_array[-1]} )
	diskfree="${last_line_array[3]/%%}"

	echo "$diskfree"
}

function get_mem_as_json_array {
	# vars
	local meminfo_parameter_field meminfo_size_field
	local -i MemTotal=-1 MemAvailable=-1

	# flags
	local -i is_both_parameters_read_ok_FLAG=0

	# code
	#MemTotal:        8074824 kB
	#MemFree:         5573512 kB
	#MemAvailable:    5697504 kB
	#Buffers:           51764 kB
	while read -r meminfo_parameter_field meminfo_size_field _ || [[ -n "$meminfo_parameter_field" ]]; do
		[[ "$meminfo_parameter_field" == 'MemTotal:' ]] && (( MemTotal = meminfo_size_field ))
		[[ "$meminfo_parameter_field" == 'MemAvailable:' ]] && (( MemAvailable = meminfo_size_field ))
		if (( MemTotal != -1 && MemAvailable != -1 )); then
			is_both_parameters_read_ok_FLAG=1
			break
		fi
	done < /proc/meminfo

	if (( is_both_parameters_read_ok_FLAG )); then
		echo "[$(( MemTotal / 1024 )),$(( MemAvailable / 1024 ))]"
	else
		echo 'null'
	fi
}

function get_saved_last_cmd_id {
	# vars
	local saved_last_cmd_id

	# code
	if [[ -s "$last_cmd_id_FILE" ]]; then
		saved_last_cmd_id="$( < "$last_cmd_id_FILE" )"
		(( script_DEBUG )) && log_line debug "[DEBUG] $last_cmd_id_FILE content is $saved_last_cmd_id" 1>&2 # TODO modify library to bear this redirection
	else
		saved_last_cmd_id=''
	fi

	(( script_DEBUG )) && log_line debug "[DEBUG] saved_last_cmd_id is '$saved_last_cmd_id'" 1>&2
	echo "$saved_last_cmd_id"
}

function process_total_khs_and_arr {
	#
	# compute, display and write out 'arr' (Accepted/Rejected Ratio) and 'khs' files for watchdog and averager
	#

	# vars
	local -i total_khs_integer
#	local arr_rounded_to_2 arr_to_display

	# code

	# !!! arr section temporary DISABLED
	# not required yet, disabled -- waiting for ARR Watchdog to come someday

#	if is_JSON_string_not_empty_or_null "$stats"; then
#		arr_rounded_to_2="$(
#			jq 'def roundit: . * 100.0 + 0.5 | floor / 100.0;
#				try (
#					.ar | . as [$accepted,$rejected,$incorrect] | add |
#					if . > 10 then
#						$accepted / . * 100 | roundit
#					else
#						null
#					end
#				)
#				catch null
#			' <<< "$stats"
#		)"
#	fi

#	if is_JSON_string_not_empty_or_null "$arr_rounded_to_2"; then
#		arr_to_display=" (${arr_rounded_to_2}% accepted)"
#		printf '%.0f\n' "$arr_rounded_to_2" > "$arr_FILE"
#	else
#		arr_to_display=''
#		printf 'null\n' > "$arr_FILE" # watchdog won't bark in case of null
#	fi
#	(( script_DEBUG )) && debug_print_variable 'arr_rounded_to_2'

	# total_khs section
	if [[ -z "$total_khs" || "$total_khs" == '0' || "$total_khs" == 'null' ]]; then
		total_khs_integer=0
	else
		total_khs_integer="$( scientific_to_integer "$total_khs" )"
	fi

	if (( total_khs_integer > 0 )); then
		log_line info "$MINER hashrate ${WHITE}$( khs_to_human_friendly_hashrate "$total_khs" )${NOCOLOR}$arr_to_display, stats collected in ${WHITE}${time_wasted_collecting_stats_in_s}s"
		echo "$total_khs" > "$total_khs_FILE" # write actual total_khs to file (for watchdog and averager)
	else
		log_line warning "$MINER hashrate ${WHITE}0 H/s${NOCOLOR}$arr_to_display, stats collected in ${WHITE}${time_wasted_collecting_stats_in_s}s"
		echo '0' > "$total_khs_FILE" # write 0 khs to file (for watchdog and averager)
	fi
}

function get_avg_khs_as_json {
	#
	# reads avg_khs JSON object from a corresponding file (prepared by averager)
	# NB: if file is older than some value, output nothing (anyway it will be null later)
	#

	# vars
	local -i the_now avg_khs_FILE_last_updated_time seconds_passed_since_last_updated

	# code
	if [[ -s "$avg_khs_FILE" ]]; then
		# check the file for freshness
		avg_khs_FILE_last_updated_time="$( get_file_last_modified_time_in_seconds "$avg_khs_FILE" )"
		set_variable_to_current_system_time_in_seconds 'the_now'

		(( seconds_passed_since_last_updated = the_now - avg_khs_FILE_last_updated_time ))

		if (( seconds_passed_since_last_updated < 120 )); then
			#                                     ^^^ TODO should set this time to double of averager's calculating interval
			# shellcheck disable=SC2005
			# bc it's a pure bash cat emulaton
			echo "$( < "$avg_khs_FILE" )"
		fi
	fi
}

function fetch_stats_and_push_them_to_server {
	# vars
	local -i curl_exitcode
	local -i time_start_collecting_stats time_start_sending_stats
	local time_wasted_collecting_stats_in_s time_wasted_sending_stats_in_s
	local PUSH_INTERVAL custom_interval_message
	local cpuavg df last_cmd_id avg_khs
	local -i current_RIG_CONF_last_updated_time=0 current_WALLET_CONF_last_updated_time=0

	# code
	is_program_in_the_PATH 'jq' || log_line error 'jq not found'

	# RIG_CONF. load it only at the very start or if updated (considering modification time)
	if [[ -s "$RIG_CONF" ]] && current_RIG_CONF_last_updated_time="$( get_file_last_modified_time_in_seconds "$RIG_CONF" )"; then
		if (( saved_RIG_CONF_last_updated_time == 0 || saved_RIG_CONF_last_updated_time != current_RIG_CONF_last_updated_time )) ; then
			#                       first time ^^^^                             updated ^^
			log_line action "Loading rig config $RIG_CONF"
			source "$RIG_CONF"
			(( saved_RIG_CONF_last_updated_time = current_RIG_CONF_last_updated_time ))
		fi
	else
		log_line error "Rig config $RIG_CONF not found, waiting..."
		return
	fi

	# WALLET_CONF. load it only at the very start or if updated (considering modification time)
	if [[ -s "$WALLET_CONF" ]] && current_WALLET_CONF_last_updated_time="$( get_file_last_modified_time_in_seconds "$WALLET_CONF" )"; then
		if (( saved_WALLET_CONF_last_updated_time == 0 || saved_WALLET_CONF_last_updated_time != current_WALLET_CONF_last_updated_time )); then
			#                          first time ^^^^                                updated ^^
			log_line action "Loading wallet config $WALLET_CONF"
			source "$WALLET_CONF"
			(( saved_WALLET_CONF_last_updated_time = current_WALLET_CONF_last_updated_time ))
		fi
	else
		log_line warning "Wallet config $WALLET_CONF not found, trying to move on without it"
	fi

	# if rig config contains PUSH_INTERVAL then change default to custom
	if [[ -n "${PUSH_INTERVAL-}" ]] && (( PUSH_INTERVAL != push_interval_DEFAULT )); then
		INTERVAL="$PUSH_INTERVAL"
		custom_interval_message="${LGRAY}[push interval ${INTERVAL}s]${NOCOLOR} "
	else
		INTERVAL="$push_interval_DEFAULT"
		custom_interval_message=''
	fi

	[[ -n "$TIMEZONE" ]] && export TZ="$TIMEZONE"

	# let's send stats even if no FS applied
	[[ -z "$MINER" || "$MINER" == 'claymore' ]] && MINER='asicminer'
	[[ -z "$META" ]] && META='{"asicminer":{"coin":"N/A"}}'

	log_line info "${custom_interval_message}Collecting stats from ${WHITE}${MINER}${NOCOLOR} API..."

	time_start_collecting_stats="$( get_system_uptime_in_milliseconds )"
	fetch_miner_stats "$MINER"
	time_wasted_collecting_stats_in_s="$( get_time_difference_in_s $(( time_start_collecting_stats )) )"

	process_total_khs_and_arr

	mem="$( get_mem_as_json_array )"
	cpuavg="$( get_loadavg_as_json_array )"
	df="$( get_diskfree_as_string )"
	last_cmd_id="$( get_saved_last_cmd_id )"
	avg_khs="$( get_avg_khs_as_json )"

	# construct a request
	request="$(
		jq --null-input --compact-output						\
			--argjson	rig_id			"${RIG_ID:-null}"		\
			--arg		passwd			"$RIG_PASSWD"			\
			--argjson	last_cmd_id		"${last_cmd_id:-null}"	\
			--arg		miner			"$MINER"				\
			--argjson	meta			"${META:-null}"			\
			--argjson	miner_stats		"${stats:-null}"		\
			--argjson	total_khs		"${total_khs:-null}"	\
			--argjson	avg_khs			"${avg_khs:-null}"		\
			--arg		system_status	"$system_status"		\
			--arg		df				"$df"					\
			--argjson	mem				"${mem:-null}"			\
			--argjson	cpuavg			"${cpuavg:-null}"		\
																\
			'def walk(f):
				. as $in
				| if type == "object" then
					reduce keys_unsorted[] as $key
					( {}; . + { ($key):  ($in[$key] | walk(f)) } ) | f
				elif type == "array" then
					map( walk(f) ) | f
				else
					f
				end;
			{
				"method": "stats", "jsonrpc": "2.0", "id": 0,
				"params": {
					$rig_id, $passwd, $last_cmd_id,
					$miner, $meta,
					$miner_stats, $total_khs, $avg_khs,
					$system_status, $df, $mem, $cpuavg
				}
			} | walk(
					if type == "object" then
						with_entries(select( .value != null and .value != {} and .value != [] ))
					elif type == "array" then
						map(select( . != null and . != {} and .!= [] ))
					else
						.
					end
				)' # remove: 1. empty objects; 2. empty arrays; 3. keys with null value
	)"

	# fall-back route (like in case of a broken jq or some)
	if [[ $? -ne 0 || -z "$request" ]]; then
		log_line error 'Something went wrong while constructing a JSON request. Fall back to a safe mode...'
		debug_print_variable 'RIG_ID' 'last_cmd_id' 'META' 'stats' 'total_khs' 'avg_khs' 'cpuavg'
		# good ol' bash string assembly
		request="{\"method\":\"stats\",\"jsonrpc\":\"2.0\",\"id\":0,\"params\":{\"rig_id\":${RIG_ID},\"passwd\":\"${RIG_PASSWD}\",\"miner\":\"$MINER\",\"system_status\":\"$system_status\"}}"
	fi

	# show the request, password cloaked
	jq '.params.passwd=$cloaked_pass' --arg cloaked_pass "${RIG_PASSWD//?/*}" --compact-output <<< "$request"

	if [[ -z "$RIG_ID" ]]; then
		log_line warning "No RIG_ID, skipping sending stats"
		return
	fi

	HIVE_URL="$HIVE_HOST_URL"
	HIVE_URL_collection[0]="$HIVE_URL" # 0th index is for an original HIVE_HOST_URL
	HIVE_URL_collection[1]="$HIVE_URL" # 1st index is for an original HIVE_HOST_URL, second connection attempt

	# !!! and now the duct tape
	# protection measures -- we don't have https on the vast majority of ASICs
	if [[ "$HIVE_URL" == 'https://'* ]]; then
		log_line warning "API server $HIVE_URL is not supported, most likely"
		HIVE_URL_collection[1]="${HIVE_URL/https:\/\//http:\/\/}" # and 2nd place for an http form of https'ed HIVE_HOST_URL
		if (( ! https_disabled_message_sent_FLAG )); then
			cp "$RIG_CONF" "${RIG_CONF}.original"
			sed -i 's|HIVE_HOST_URL="https://|HIVE_HOST_URL="http://|' "$RIG_CONF"
			message warning "Server URL with HTTPS might not be supported on this ASIC. It's recommended to switch to HTTP (Settings->Mirror select)" --silent
			mv "${RIG_CONF}.original" "$RIG_CONF"
			https_disabled_message_sent_FLAG=1
		fi
	fi

	local -i curl_connect_timeout=5 curl_max_time=7 # a somewhat shorter timeouts for the first attempt
	local -i attempts_counter=1
	for this_URL in "${HIVE_URL_collection[@]}"; do
		if [[ "$HIVE_URL" != *'hiveos.farm'* && "$this_URL" == *'hiveos.farm'* ]]; then
			log_line warning "Whitelabel HIVE_HOST_URL detected, sending stats to ${this_URL} skipped..."
			break
		fi
		if (( attempts_counter == 1 )); then
			log_line info "Sending stats (${#request} bytes) to ${this_URL}..."
		else
			log_line warning "Re-sending stats (${#request} bytes) to ${this_URL} (attempt #$attempts_counter)..."
		fi
		time_start_sending_stats="$( get_system_uptime_in_milliseconds )"
		response="$(
			curl \
				--verbose --trace-time --insecure --location --data @- \
				--connect-timeout "$curl_connect_timeout" --max-time "$curl_max_time" \
				--silent --fail \
				--request POST "${this_URL}/worker/api?id_rig=$RIG_ID&method=stats" \
				--header 'Content-Type: application/json' \
				\
			<<< "$request" \
			2> "$latest_curl_log"
		)"
		curl_exitcode=$?
		time_wasted_sending_stats_in_s="$( get_time_difference_in_s $(( time_start_sending_stats )) )"

		if (( curl_exitcode )); then
			log_line error "Error sending stats with exitcode $curl_exitcode in ${WHITE}${time_wasted_sending_stats_in_s}s${NOCOLOR}. Connection log:"
			# shellcheck disable=SC2005
			echo "$( < "$latest_curl_log" )"
			# bc it's a pure bash cat emulation
			sleep_with_progress_bar 1
		else
			break
		fi

		(( curl_connect_timeout = 15, curl_max_time = 25 )) # much longer timeouts for all next attempts
		(( attempts_counter++ ))
	done

	if [[ $curl_exitcode -ne 0 || -z "$response" ]]; then
		log_line error "No attempts left. Let's refresh the IP cache..."
		/hive/bin/timeout -t 10 /hive/bin/cache-hive-ip
		return "$curl_exitcode"
	fi


	# errors processing
	local error
	#
	error="$( jq --raw-output '.error' <<< "$response" )"
	if (( $? )); then
		log_line error "Invalid response received in ${WHITE}${time_wasted_sending_stats_in_s}s${NOCOLOR}:\n$response"
		return 1
	fi

	if is_JSON_string_not_empty_or_null "$error"; then
		log_line error "Error response received in ${WHITE}${time_wasted_sending_stats_in_s}s${NOCOLOR}: $error"
		return 1
	fi


	# command processing
	local command
	#
	command="$( jq --raw-output '.result.command' <<< "$response" )"
	if [[ "$command" == 'OK' ]]; then
		if [[ -f "$last_cmd_id_FILE" ]]; then
			(( script_DEBUG )) && log_line debug "[DEBUG] removing $last_cmd_id_FILE"
			rm "$last_cmd_id_FILE"
		fi
	else
		local response_stripped="${response//\\n/\\\\n}" # neuter the \n's
		log_line info "Server answer: $( jq --compact-output --color-output '.result' <<< "$response_stripped" )"
		skip_the_sleep_FLAG=1
	fi


	# confseq processing
	local confseq_received confseq_saved
	#
	confseq_received="$( jq --raw-output '.result.confseq' <<< "$response" )"
	if is_JSON_string_not_empty_or_null "$confseq_received"; then
		if [[ -s "$confseq_FILE" ]]; then
			confseq_saved="$( < "$confseq_FILE" )"
		else
			# first time run, just save current confseq
			confseq_saved="$confseq_received"
			echo "$confseq_received" > "$confseq_FILE"
		fi

		if (( confseq_saved != confseq_received )); then
			# save updated confseq
			echo "$confseq_received" > "$confseq_FILE"
			case "$command" in
				'config' | 'wallet' | 'asic_oc' | 'asic' )
					log_line debug "[DEBUG] config command received. Config sequence updated: $confseq_saved -> $confseq_received"
				;;
				*)
					log_line debug "[DEBUG] no config command received, but config sequence updated: $confseq_saved -> $confseq_received. Let's say hello again..." # (and then get an updated config)
					hello # TODO fork to bg?
				;;
			esac
		fi
	else
		(( script_DEBUG )) && log_line debug "[DEBUG] server answer lacks 'confseq' key, confseq processing skipped"
	fi


	# to batch or not to batch
	local body
	local -i commands_count this_command_index
	#
	if [[ "$command" != 'batch' ]]; then
		body="$( jq --compact-output '.result' <<< "$response" )"
		do_command
	else
		commands_count="$( jq '.result.commands | length' <<< "$response" )"
		log_line info "Got $commands_count batch commands"
		for (( this_command_index = 0; this_command_index < commands_count; this_command_index++ )); do
			body="$( jq --compact-output --argjson index "$this_command_index" '.result.commands[$index]' <<< "$response" )"
			command="$( jq --raw-output '.command' <<< "$body" )" # get command for batch
			do_command
		done
	fi
}

function backslash {
	local var="${1//\\/\\\\}"
	var="${var//\"/\\\"}"
	var="${var//\`/\\\`}"
	var="${var//\$/\\\$}"
	echo "$var"
}

function do_command {
	# consts
	local -r command_log="/tmp/${script_basename}-${command// /-}.log"

	# vars
	local cmd_id version exec shutdown_fuse_file exectimeout asic_oc firmware_url
	local config justwrite line NEW_PASSWD request response error wallet
	local -i curl_exitcode time_limit
	# shellcheck disable=SC2034
	# bc it's used in a weird way (in the sinlge quoted commands group)
	local -i exec_exitcode
	#local TMUX	# let's test it later

	# code
#	[[ -z "$command" ]] && command="$( jq --raw-output '.command' <<< "$body" )" #get command for batch

	# cmd_id processing (optional command identifier)
	cmd_id="$( jq --raw-output '.id' <<< "$body" )"
	is_JSON_string_empty_or_null "$cmd_id" && cmd_id=''
	# save last cmd_id
	(( script_DEBUG )) && log_line debug "[DEBUG] incoming cmd_id is '$cmd_id'"
	if (( cmd_id > 0 )); then
		(( script_DEBUG )) && log_line debug "[DEBUG] saving cmd_id '$cmd_id' to $last_cmd_id_FILE"
		echo "$cmd_id" > "$last_cmd_id_FILE"
	fi

	log_line ok "'$command' received in ${WHITE}${time_wasted_sending_stats_in_s}s"

	case "$command" in
		'OK')
			# do nothing
			:
		;;

		'reboot')
			message ok 'Rebooting' --id="$cmd_id" --silent
			log_line ok 'Rebooting'
			#nohup bash -c 'sreboot' > "$command_log" 2>&1 &
			/sbin/reboot
		;;

		'upgrade')
			version="$( jq --raw-output '.version' <<< "$body" )"
			is_JSON_string_empty_or_null "$version" && version=
			screen -dm -S selfupgrade bash -c '
				selfupgrade '"$version"' 2>&1 | tee '"$command_log"'
				if (( PIPESTATUS[0] == 0 )); then
					message ok "Client update successful" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				else
					message error "Client update failed" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				fi
			'
		;;

		'upgrade beta')
			screen -dm -S selfupgrade bash -c '
				selfupgrade master 2>&1 | tee '"$command_log"'
				if (( PIPESTATUS[0] == 0 )); then
					message ok "Client update successful" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				else
					message error "Client update failed" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				fi
			'
		;;

		'exec')
			exec="$( jq --raw-output '.exec' <<< "$body" )"

			# let's inform the user that the command is received
			#message default "$exec (running, id: $cmd_id)" --id="$cmd_id" --verbose

			case "$exec" in
				'hssh start')
					unset TMUX # !!! duct tape
				;;
				'sreboot shutdown')
					shutdown_fuse_file="/tmp/${script_basename}-shutdown-fuse.lock"
					if [[ ! -f "$shutdown_fuse_file" ]]; then
						message warning 'Vast majority of ASICs does not support shutdown. Click for details' --payload --id="$cmd_id" --silent <<-EOF
							<h3>Vast majority of ASICs does not support shutdown</h3>It might be the ASIC will simply go offline. You will more than likely have to power it off manually.
							If you know what are you doing, please <strong>send this command one more time</strong>
							EOF
						touch "$shutdown_fuse_file"
						return
					else
						rm "$shutdown_fuse_file"
						message ok 'ASIC powered off' --id="$cmd_id" --silent
						snore 5 # wait 5s until the message has been sent
					fi
				;;
			esac

			# !!! a secret spell: if the command to exec prefixed with ':;', then no time limit enabled
			if [[ "${exec:0:2}" == ':;' ]]; then
				exectimeout='nohup bash -c' # no time limit at all
			else
				(( time_limit = 60 * 60 * 3 )) # 3 hrs tops
				# shellcheck disable=SC2076
				if [[ "$ASIC_MODEL" == 'Zig Z1' || "$ASIC_MODEL" == 'Zig Z1+' || "$ASIC_MODEL" == 'Toddminer C1'* ]]; then
					# use Debian /usr/bin/timeout
					exectimeout="nohup timeout $time_limit bash -c"
				else
					# use a BusyBox one
					exectimeout="nohup timeout -t $time_limit bash -c"
				fi
			fi

			#
			# do we need an intermediate file? here's a file-less approach with pipe:
			#
			#$exectimeout '
			#	( '"$exec"' ) 2>&1 | if (( $? == 0 )); then
			#		message info "'"$( backslash "$exec" )"'" --payload --id='"$cmd_id"'
			#	else
			#		message error "'"$( backslash "$exec" )"' (failed, exitcode=$?)" --payload --id='"$cmd_id"'
			#	fi
			#' > "$command_log" 2>&1 &

			local agent_exec_log="/tmp/agent-exec-$cmd_id.log"
			#local exec_backslashed="$( backslash "$exec" )" # don't need it anymore

			$exectimeout '# {agent-exec}
				( '"$exec"' ) > "$1" 2>&1
				exec_exitcode=$?
				if (( exec_exitcode == 0 )); then
					message info "$0" --escape-templates --id="$2" --silent --payload < "$1"
				else
					message error "$0 (failed, exitcode=$exec_exitcode)" --escape-templates --id="$2" --silent --payload < "$1"
				fi
				rm "$1" > /dev/null 2>&1
			' "$exec" "$agent_exec_log" "$cmd_id" > "$command_log" 2>&1 & disown
		;;

		'asic_oc')
			if is_screen_session_exist "$command"; then
				screen_session_terminate "$command"
				log_line warning "Command '$command' already running. Terminated."
				snore 1
			fi
			export asic_oc="$( jq --raw-output '.asic_oc' <<< "$body" )"
			[[ -f /config/use-new-asic-oc ]] && mv /config/use-new-asic-oc /hive-config/use-new-asic-oc # adjusting legacy location to an actual one
			# !!!                      a secret feature vvvvvvvvvvvvvvvvvvvvvvvvvvvv
			if [[ "$ASIC_MODEL" == 'Antminer L3+'* && ( "$ASIC_CUSTOM_FW_VERSION" == '1.02' || "$ASIC_CUSTOM_FW_VERSION" == '1.03' ) ]] || (( ASIC_CUSTOM_FW_VERSION_MAJOR >= 2 )) || [[ -f /hive-config/use-new-asic-oc ]]; then
				asic_oc_cmd='asic-oc'
			else
				asic_oc_cmd='asic_oc'
			fi
			screen -dm -S "$command" bash -c '
				echo "Auto-tune parameters:"
				echo
				jq "." <<< "$asic_oc"
				echo
				'"$asic_oc_cmd"' "$asic_oc" 2>&1 | tee '"$command_log"'
				if (( PIPESTATUS[0] == 0 )); then
					message ok "Auto-tune is finished. Click for details" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				else
					message error "Auto-tune error. Click for details" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				fi
			'
		;;

		'firmware-upgrade')
			if is_screen_session_exist "$command"; then
				log_line warning "Command '$command' already running. Execution skipped."
				message warning "Firmware upgrade skipped. Click for details" --payload --id="$cmd_id" --silent <<< "Previous firmware upgrade process is still running. Please wait for it to finish and then send the command again."
				return
			fi
			export firmware_url="$( jq --raw-output '.firmware_url' <<< "$body" )"
			screen -dm -S "$command" bash -c '
				firmware-upgrade "$firmware_url" 2>&1 | tee '"$command_log"'
				if (( PIPESTATUS[0] == 0 )); then
					message ok "Firmware upgrade successful, rebooting..." --payload --id='"$cmd_id"' --silent < '"$command_log"'
				else
					message error "Firmware upgrade failed" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				fi
			'
		;;

		'config')
			config="$( jq --raw-output '.config' <<< "$body" )"
			justwrite="$( jq --raw-output '.justwrite' <<< "$body" )" #don't restart miner, just write config, maybe WD settings will be updated
			if is_JSON_string_not_empty_or_null "$config"; then
				#scan for password change
				while read -r line; do
					if [[ "$line" =~ ^RIG_PASSWD=\"(.*)\" ]]; then
						NEW_PASSWD="${BASH_REMATCH[1]}"
						break
					fi
				done <<< "$config"

				# Password change ---------------------------------------------------
				if [[ "$RIG_PASSWD" != "$NEW_PASSWD" ]]; then
					log_line warning "Old password: $RIG_PASSWD, new password: $NEW_PASSWD"

					message warning 'New password received, please wait for the green message...' --id="$cmd_id" --silent
					request="$( jq --null-input --compact-output \
						--arg rig_id "$RIG_ID" --arg passwd "$RIG_PASSWD" \
						'{ "method": "password_change_received", "params": {$rig_id, $passwd}, "jsonrpc": "2.0", "id": 0}'
					)"
					response="$(
						curl --insecure --location --data @- --connect-timeout 15 --max-time 25 --silent \
						--request POST "${HIVE_URL}/worker/api?id_rig=$RIG_ID&method=password_change_received" \
						--header "Content-Type: application/json" \
						<<< "$request"
					)"

					curl_exitcode=$?
					if (( curl_exitcode != 0 )); then
						message error 'Error notifying hive about "password_change_received"' --id="$cmd_id" --silent
						return "$curl_exitcode" #better exit because password will not be changed
					fi

					error="$( jq --raw-output '.error' <<< "$response" )"
					if is_JSON_string_not_empty_or_null "$error"; then
						log_line error "Server error: $( jq --raw-output '.error.message' <<< "$response" )"
						return 1
					fi

					jq '.' <<< "$response"
					#after this there will be new password on server, so all new request should use new one
				fi

				# Write new config and load it ---------------------------------------
				echo "$config" > "$RIG_CONF" && sync
				source "$RIG_CONF"

				# Save wallet if given -----------------------------------------------
				wallet="$( jq --raw-output '.wallet' <<< "$body" )"
				is_JSON_string_not_empty_or_null "$wallet" && echo "$wallet" > "$WALLET_CONF"

				# Overclocking if given in config --------------------------------------
#				oc_if_changed

				# Final actions ---------------------------------------------------------
				if [[ "$justwrite" != 1 ]]; then
					#hostname-check
					/hive/bin/miner restart
					echo
				fi

				# Start Watchdog. It will exit if WD_ENABLED=0 ---------------------------
				if (( "${WD_ENABLED:-0}" )); then
					nohup wd stop > /dev/null 2>&1
					snore 5
				fi
				wd start &

				message ok 'Rig config changed' --id="$cmd_id" --silent
				#[[ $? -eq 0 ]] && message ok 'Wallet changed, miner restarted' --id=$cmd_id || message warn "Error restarting miner" --id=$cmd_id
				sync
			else
				message error 'No rig "config" given' --id="$cmd_id" --silent
			fi
		;;

		'wallet')
			wallet="$( jq --raw-output '.wallet' <<< "$body" )"
			if is_JSON_string_not_empty_or_null "$wallet"; then
				echo "$wallet" > "$WALLET_CONF" && sync

				justwrite=
#				oc_if_changed

				/hive/bin/miner restart
				if (( $? == 0 )); then
					message ok 'Wallet changed, miner restarted' --id="$cmd_id" --silent
				else
					message warn 'Error restarting miner' --id="$cmd_id" --silent
				fi
			else
				message error 'No "wallet" config given' --id="$cmd_id" --silent
			fi
		;;

		'asic')
			hiveon_config="$( jq --raw-output '.asic' <<< "$body" )"
			if is_JSON_string_not_empty_or_null "$hiveon_config"; then
				grep -v '^_' <<< "$hiveon_config" > "$HIVEON_CONF"
				grep -v '^_' <<< "$hiveon_config" > "$ASIC_CONF"
				grep '^_' <<< "$hiveon_config" > "$HIVEON_CONF_VOLT"
				sync
				/hive/bin/miner restart
				if (( $? == 0 )); then
					message ok 'ASIC config changed, miner restarted' --id="$cmd_id" --silent
				else
					message warn 'Error restarting miner' --id="$cmd_id" --silent
				fi
			else
				message error 'No "asic" config given' --id="$cmd_id" --silent
			fi
		;;


		*)
			log_line error "Unknown command received: '$command'"
		;;

	esac
}

function sleep_with_progress_bar {
	#
	# print a shrinking progress bar while sleeping
	#
	# Usage: sleep_with_progress_bar 'seconds_to_sleep'
	#

	# args
	local -r -i seconds_to_sleep="$1"

	# vars
	local -i this_step
	local seconds_remaining_as_spaces seconds_remaining_as_dots

	# code

	for (( this_step = 0; this_step < seconds_to_sleep; this_step++ )); do
		printf -v seconds_remaining_as_spaces '%*s' $(( seconds_to_sleep - this_step ))
		seconds_remaining_as_dots="${seconds_remaining_as_spaces// /.}"
		printf '\r%b%s%b%*s\r' "${DGRAY}" "$seconds_remaining_as_dots" "${NOCOLOR}" "$this_step"
		snore 1
	done
	printf '\r%*s\n' "$seconds_to_sleep" # clear the line and then \n
}


# global traps

trap -- 'errcho "SIGHUP received, ignoring..."' SIGHUP


# global consts

# paths to conf files
declare -r RIG_CONF='/hive-config/rig.conf'
declare -r WALLET_CONF='/hive-config/wallet.conf'
declare -r HIVEON_CONF='/hive-config/hiveon.conf'
declare -r HIVEON_CONF_VOLT='/hive-config/hiveon.conf'
declare -r ASIC_CONF='/config/config.conf'
# path to runtime vars
declare -r total_khs_FILE='/run/hive/khs'
declare -r avg_khs_FILE='/run/hive/khs_avg' # Averages in JSON format
declare -r arr_FILE='/run/hive/arr' # Accepted/Rejected ratio * 100
declare -r last_cmd_id_FILE='/run/hive/last_cmd_id'
declare -r confseq_FILE='/run/hive/confseq'

declare -r latest_curl_log="/run/hive/${script_basename}-curl.log"  # looks like /tmp on a few models (at least on S9 hiveon) is on top of NAND -- let's wear it less
declare -r miner_API_host='localhost'
declare -r -i miner_API_port=4028
declare -r -i push_interval_DEFAULT=10


# global vars

declare MINER='asicminer'
declare total_khs system_status stats
declare -i INTERVAL=push_interval_DEFAULT
declare -i time_wasted_general time_remaining_general
declare -a HIVE_URL_collection=( # indices 0 and 1 are reserved for HIVE_HOST_URL from RIG_CONF
	[2]='http://api.hiveos.farm'
	[3]='http://paris.hiveos.farm'
	[4]='http://amster.hiveos.farm'
	[5]='http://helsinki.hiveos.farm'
	[6]='http://msk.hiveos.farm'
	[7]='http://ca1.hiveos.farm'
)
declare -i saved_RIG_CONF_last_updated_time=0 saved_WALLET_CONF_last_updated_time=0


# global flags

declare -i https_disabled_message_sent_FLAG=0 skip_the_sleep_FLAG=0


# sources

[[ -t 1 ]] && source colors
source asic-model
source /hive/bin/hive-functions.sh || { echo 'ERROR: /hive/bin/hive-functions.sh not found'; exit 1; }


# main

#$PPID - might be parent screen pid
screen_count="$( screen -ls | grep "\.agent" | grep -Fcv "$PPID" )"

#there will be still 1 process for subshell
#[[ `ps aux | grep "./agent" | grep -vE "grep|screen|SCREEN|$$" | wc -l` -gt 1 ]] &&
if (( screen_count > 0 )); then
	echo -e "${RED}Agent screen is already running${NOCOLOR}"
	echo -e "Run ${CYAN}agent-screen${NOCOLOR} to resume screen"
	exit 1
fi

log_line ok "$script_mission, version $script_version started"
log_line info "Detected ASIC model: ${WHITE}$ASIC_MODEL"
	echo

# (re)starting wd

if (( "${WD_ENABLED:-0}" )); then
	nohup wd stop > /dev/null 2>&1
	snore 5
fi
wd start &

# main loop

while true; do
	SECONDS=0
	skip_the_sleep_FLAG=0

	fetch_stats_and_push_them_to_server

	if (( skip_the_sleep_FLAG )); then
		# no interval to make the agent more responsive and instantly push last_cmd_id to the server
		echo
		(( script_DEBUG )) && log_line warning '[DEBUG] skip the nap to improve responsiveness after receiving a command'
	else
		(( time_wasted_general = SECONDS ))
		(( time_remaining_general = INTERVAL - time_wasted_general ))

		(( time_remaining_general < 0 )) && log_line warning "Stats gathering/sending cycle took ${time_wasted_general}s, overtime is ${time_remaining_general/-}s"

		sleep_with_progress_bar "$INTERVAL"
	fi
done
